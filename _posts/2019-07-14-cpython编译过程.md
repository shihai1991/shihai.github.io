---
published: true
layout: post
title: cpython编译过程分析
category: container
tags:
  - cpython
time: '2019.07.14 13:24:00'
excerpt: cpython编译过程入门学习
---

## decode过程分析

cpython在编译源码过程会先判断source code使用的编码方案，因为不同的编码方式意味着不同的解码过程。
我这里用一个demo来演示一下python是如何来判断编码方案。
```
# 我有一个fab算法文件存放于 /home/shihai/test_fab.py中，具体内容如下所示：
def fab(max):
    n, a, b = 0, 0, 1
    L = []
    while n < max:
        L.append(b)
        a, b = b, a+b
        n = n + 1
    return L

for n in fab(5):
    print n

# 打开python编译器并调用tokenizen模块来查看此过程（python默认的编码格式utf-8）
$ ./python
Python 3.9.0a0 (heads/master:c8e7146, Jul 13 2019, 11:42:31)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>import tokenize
>>>fd = open("/home/shihai/test_fab.py", "rb")
>>>encoding, lines = tokenize.detect_encoding(fd.readline)
>>>encoding
'utf-8'
>>>lines
[b'\n', b'def fab(max):\n']
```


## tokenize过程分析

tokenize是将代码解析成word的过程

```
# 用tokenize模块(tokenize模块是python的词汇扫描模块)进行代码解析过程后得到所有解析后的words
$ cat /home/shihai/test_fab.py| ./python -m tokenize -e
1,0-1,3:            NAME           'def'
1,4-1,7:            NAME           'fab'
1,7-1,8:            LPAR           '('
1,8-1,11:           NAME           'max'
1,11-1,12:          RPAR           ')'
1,12-1,13:          COLON          ':'
1,13-1,14:          NEWLINE        '\n'
2,0-2,4:            INDENT         '    '
2,4-2,5:            NAME           'n'
2,5-2,6:            COMMA          ','
2,7-2,8:            NAME           'a'
2,8-2,9:            COMMA          ','
2,10-2,11:          NAME           'b'
2,12-2,13:          EQUAL          '='
2,14-2,15:          NUMBER         '0'
2,15-2,16:          COMMA          ','
```

[Tokens define](https://github.com/python/cpython/blob/master/Grammar/Tokens)


## parse过程分析

parse过程是将words构建出parse tree(实际的抽象层次低于AST),由node数据结构构成
```
# x=3+2的过程会变成这个样子

Python 3.6.8 (default, Aug  7 2019, 17:28:10)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pprint import pprint
>>> import parser
>>> st = parser.expr('3+2')
>>> pprint(parser.st2list(st))
[258,
 [331,
  [305,
   [309,
    [310,
     [311,
      [312,
       [315,
        [316,
         [317,
          [318,
           [319,
            [320, [321, [322, [323, [324, [2, '3']]]]]],
            [14, '+'],
            [320, [321, [322, [323, [324, [2, '2']]]]]]]]]]]]]]]]],
 [4, ''],
 [0, '']]
```
[node's access function](https://github.com/python/cpython/blob/master/Include/node.h)
[node's type](https://github.com/python/cpython/blob/master/Include/graminit.h)
[symtable 1](https://github.com/python/cpython/blob/master/Include/token.h#L13)
[symtable 2](https://github.com/python/cpython/blob/master/Include/graminit.h)


## Abstract Syntax Tree

从“sentence structure”到“semantics”

```
# x = 3 + 2的过程

Module(body=
    [Assing(
        targets=[Name(id='x',
            ctx=Store())],
        value=BinOp(left=Num(n=3),
                    op=Add(),
                    right=Num(n=2)
                    )
              )
    ])
                    
```


## compile过程

从“semantics”到bytecode过程

```
# def func(): x = y + 2的字节码转换过程可以直接使用`echo "def func(): x = y + 2" | python -m dis`输出如下所示：

  1           0 LOAD_CONST               0 (<code object func at 0x7fef2cac8930, file "<stdin>", line 1>)
              3 MAKE_FUNCTION            0
              6 STORE_NAME               0 (func)
              9 LOAD_CONST               1 (None)
             12 RETURN_VALUE
```

什么是control flow graph?
